<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/p5.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Drip</title>
    <meta charset="utf-8" />

  </head>
  <body>
    <main>
    </main>
    <script>
const CANVAS_SIZE = 800;

let num_points = 60;
let thickness = CANVAS_SIZE / 40;
let inner_radius = CANVAS_SIZE / 5;
let outer_radius = inner_radius + thickness; // treated as fixed visual rim; thickness adjusts inward

let points = [];
let springs = [];
let obstacles = [];
let draggingObstacle = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let draggingBlob = false;
let draggedPointIndex = -1;
const MOUSE_SPRING_K = 6000;
const MOUSE_SPRING_DAMP = 100;
const MOUSE_MAX_FORCE = 20000;

const FRAME = 60;
const RATE = 1 / FRAME;
const BASE_GRAVITY = 50; // baseline gravity acceleration
const BACKGROUND_BLUE = 222; // fixed blue channel for background
const OBSTACLE_COUNT = 6; // target number of obstacles kept in play (2x frequency)
const OUTER_RIM_K = 20000;
const INNER_SPOKE_K = 400;
let BLOB_FILL_GRAY = 0; // grayscale value used for blob fills
// Space-bar toggle to pause/resume spawning new obstacles
let SPAWN_PAUSED = false;
// Distributed tug parameters
const DRAG_NEIGHBOR_RANGE = 2; // number of neighbors on each side
const DRAG_NEIGHBOR_DECAY = 0.6; // weight falloff per step
const DRAG_PAIR_WEIGHT = 0.5; // how strongly the paired ring participates
const DRAG_DAMP_MULTIPLIER = 2.0; // extra damping during drag to reduce jiggle

// Symmetry / visualization controls
let ADD_RANDOM_CROSS_SPRINGS = false; // true = more tangled chords, false = cleaner symmetry
let DRAW_ALL_INTERNAL_SPRINGS = false; // true = draw every spring, false = mostly rim
let DRAW_CENTER_SPRINGS = false; // draw spokes to center if true
const HUB_RADIUS = 20; // visual hub radius in pixels

// Soft body instance (encapsulates points, springs, radii, vertex count)
let softBody = null;

// Stabilization controls to discourage self-wrapping
let PRESSURE_K = 0.005; // area restoring coefficient (safer)
let SELF_REPEL_STRENGTH = 15000; // short-range rim repulsion (safer)
let SELF_REPEL_RADIUS = thickness * 1.6; // slightly larger minimum separation
let restOuterArea = 0; // computed at setup
let BENDING_K = 150; // rim bending stiffness
let BEND_SPRING_K = 800; // bend springs between every second outer node
let VISC_BEND_COEF = 0.25; // velocity smoother coefficient
// Safety clamps
let MAX_PRESSURE_FORCE = 2500;
let MAX_EXTRA_FORCE = 6000; // for repulsion and bending contributions
let CONTACT_BAND = 8; // pixel band around obstacle surfaces where friction engages
// Obstacle dynamics constants
let OBSTACLE_DENSITY = 0.005; // mass per pixel^2 for obstacles
let OBSTACLE_DAMPING = 3.5; // velocity damping for obstacles
let CONTACT_FORCE_FACTOR = 0.25; // scales blob->obstacle force transfer
let BLOB_MASS_PER_AREA = 0.002; // blob mass per pixel^2 (scaled by density)
// Force visualization
const FORCE_VIS_SCALE = 0.03; // pixels per unit force
const FORCE_VIS_MAX_LEN = 120; // clamp for display
const BLOB_FORCE_EMA = 0.25; // smoothing for blob net-force arrow
let blobVisFx = 0; // EMA state: blob force x
let blobVisFy = 0; // EMA state: blob force y
const VELOCITY_VIS_SCALE = 1.2; // fallback scale for velocity arrows
const ARROW_HEAD_SIZE = 8; // size of arrow heads in pixels

// UI sliders for background color
let rSlider, vertexSlider, gravitySlider, densitySlider, fillColorSlider, thicknessSlider, frictionSlider, obstacleDensitySlider;
// UI labels positioned next to sliders
let rLabel, vertexLabel, gravityLabel, densityLabel, thicknessLabel, fillLabel, frictionLabel, obstacleDensityLabel;
let uiPanel;
// UI checkboxes for visibility
let fillCheckbox, rimCheckbox, wireCheckbox, pointsCheckbox, solidCheckbox;
// Base vertices for scaling
let BASE_NUM_POINTS;

function setup() {
	frameRate(FRAME);
	createCanvas(1200, 800);

	// Inline sliders at upper-left of canvas
	textSize(15);
	// Panel backdrop
	uiPanel = createDiv('');
	uiPanel.position(8, 8);
	uiPanel.style('background', 'rgba(255,255,255,0.7)');
	uiPanel.style('border', '1px solid #000');
	uiPanel.style('padding', '8px');
	uiPanel.style('width', '360px');
	uiPanel.style('height', '420px');
	uiPanel.style('z-index', '0');

	rSlider = createSlider(0, 255, 255);
	rSlider.position(20, 20);
	styleSlider(rSlider);
	// Vertex count slider (centered at 1x): value in [-1,1] mapped to factor 2^v => [0.5,2]
	vertexSlider = createSlider(-1, 1, 0, 0.01);
	vertexSlider.position(20, 50);
	styleSlider(vertexSlider);
	// Gravity scale slider: 0.5x .. 2x (center at 1.0)
	gravitySlider = createSlider(0.5, 5.0, 1.0, 0.01);
	gravitySlider.position(20, 80);
	styleSlider(gravitySlider);
	// Density slider: scales blob mass and pressure response (0.25x .. 2.0x)
	densitySlider = createSlider(0.25, 2.0, 1.0, 0.01);
	densitySlider.position(20, 110);
	styleSlider(densitySlider);
	// Rim thickness slider (pixels) â€“ fixed range [10, 50]
	thicknessSlider = createSlider(10, 50, constrain(thickness, 10, 50), 1);
	thicknessSlider.position(20, 140);
	styleSlider(thicknessSlider);
	// Blob fill color slider (grayscale 0..255)
	fillColorSlider = createSlider(0, 255, 0, 1);
	fillColorSlider.position(20, 170);
	styleSlider(fillColorSlider);
	// Surface friction slider (0 = slippery, higher = stickier)
	frictionSlider = createSlider(0, 10, 2.5, 0.1);
	frictionSlider.position(20, 200);
	styleSlider(frictionSlider);
	// Obstacle material density (relative)
	obstacleDensitySlider = createSlider(0.25, 4.0, 1.0, 0.01);
	obstacleDensitySlider.position(20, 230);
	styleSlider(obstacleDensitySlider);

	// Labels next to sliders (sans-serif)
	rLabel = createDiv('red');
	styleLabel(rLabel);
	rLabel.position(rSlider.x + rSlider.width + 16, rSlider.y - 4);
	vertexLabel = createDiv('vertices ' + num_points);
	styleLabel(vertexLabel);
	vertexLabel.position(vertexSlider.x + vertexSlider.width + 16, vertexSlider.y - 4);
	gravityLabel = createDiv('gravity 1.00x');
	styleLabel(gravityLabel);
	gravityLabel.position(gravitySlider.x + gravitySlider.width + 16, gravitySlider.y - 4);
	densityLabel = createDiv('density 1.00x');
	styleLabel(densityLabel);
	densityLabel.position(densitySlider.x + densitySlider.width + 16, densitySlider.y - 4);
	thicknessLabel = createDiv('rim thickness ' + Math.round(thickness) + 'px');
	styleLabel(thicknessLabel);
	thicknessLabel.position(thicknessSlider.x + thicknessSlider.width + 16, thicknessSlider.y - 4);
	fillLabel = createDiv('fill color');
	styleLabel(fillLabel);
	fillLabel.position(fillColorSlider.x + fillColorSlider.width + 16, fillColorSlider.y - 4);
	frictionLabel = createDiv('friction 0.00');
	styleLabel(frictionLabel);
	frictionLabel.position(frictionSlider.x + frictionSlider.width + 16, frictionSlider.y - 4);
	obstacleDensityLabel = createDiv('obstacle density 1.00x');
	styleLabel(obstacleDensityLabel);
	obstacleDensityLabel.position(obstacleDensitySlider.x + obstacleDensitySlider.width + 16, obstacleDensitySlider.y - 4);

	// Checkboxes (cumulative)
	fillCheckbox = createCheckbox('Display blob fill', false);
	fillCheckbox.position(20, 250);
	styleCheckbox(fillCheckbox);
	rimCheckbox = createCheckbox('Display blob border rim', false);
	rimCheckbox.position(20, 275);
	styleCheckbox(rimCheckbox);
	wireCheckbox = createCheckbox('Display blob wire-frame', true);
	wireCheckbox.position(20, 300);
	styleCheckbox(wireCheckbox);
	pointsCheckbox = createCheckbox('Display mesh points', false);
	pointsCheckbox.position(20, 325);
	styleCheckbox(pointsCheckbox);
	solidCheckbox = createCheckbox('Display blob solid interior', false);
	solidCheckbox.position(20, 350);
	styleCheckbox(solidCheckbox);
	
	// Build initial blob geometry and springs
	BASE_NUM_POINTS = num_points;
	softBody = new SoftBody(inner_radius, outer_radius, num_points);
	softBody.initializeGeometry();
	
	if (ADD_RANDOM_CROSS_SPRINGS) {
		for (var i = 0; i < 100; i++) {
			let n1 = Math.floor(2 * num_points * Math.random());
			let n2 = Math.floor(2 * num_points * Math.random());
			if (n1!= n2) {
				springs.push(new Spring(points[n1], points[n2], INNER_SPOKE_K));
			}
		}
	}

	// Initialize obstacles to match prior hardcoded circles
	obstacles = [
		new ObstacleCircle(CANVAS_SIZE/3, CANVAS_SIZE, CANVAS_SIZE/8),
		new ObstacleCircle(3*CANVAS_SIZE/3, CANVAS_SIZE, CANVAS_SIZE/16),
		new ObstacleCircle(CANVAS_SIZE*3.5/4, CANVAS_SIZE*2/3, CANVAS_SIZE/20)
	];

	// Rest area already computed within softBody.initializeGeometry()

	// Ensure space bar works even when UI elements have focus
	window.addEventListener('keydown', handleGlobalKeydown);
}

function draw() {
	const r = rSlider ? rSlider.value() : 255;
	// Vertex factor from slider ([-1,1] -> [0.5,2]) and rebuild if changed
	const vertFactor = pow(2, vertexSlider ? vertexSlider.value() : 0);
	const targetVerts = max(4, Math.round(BASE_NUM_POINTS * vertFactor));
	if (targetVerts !== num_points) {
		softBody.rebuildVertexCount(targetVerts);
		draggingBlob = false;
		draggedPointIndex = -1;
	}
	const g = 11;
	const gravScale = gravitySlider ? gravitySlider.value() : 1;
	const densityScale = densitySlider ? densitySlider.value() : 1;
    background(r, g, BACKGROUND_BLUE);
	// Update current blob fill gray for rendering functions
	BLOB_FILL_GRAY = fillColorSlider ? fillColorSlider.value() : 0;

	// Rebuild geometry if rim thickness changed
	const targetThickness = thicknessSlider ? thicknessSlider.value() : thickness;
	if (targetThickness !== thickness) {
		softBody.rebuildThickness(targetThickness);
		draggingBlob = false;
		draggedPointIndex = -1;
	}

	updatePhysics();
	// Apply constant vertical scroll based solely on gravity (decoupled from collisions)
	applyGlobalScroll();
	// Recycle obstacles that left the top and spawn new ones from below
	recycleObstacles();
	drawObjects();

	// Update dynamic labels (sans-serif HTML labels)
	if (vertexLabel) vertexLabel.html('vertices ' + num_points);
	if (gravityLabel) gravityLabel.html('gravity ' + gravScale.toFixed(2) + 'x');
	if (densityLabel) densityLabel.html('density ' + getDensityScale().toFixed(2) + 'x');
	if (thicknessLabel) thicknessLabel.html('rim thickness ' + Math.round(thickness) + 'px');
	if (frictionLabel && frictionSlider) frictionLabel.html('friction ' + (frictionSlider.value() * 1.0).toFixed(2));
	if (obstacleDensityLabel && obstacleDensitySlider) obstacleDensityLabel.html('obstacle density ' + obstacleDensitySlider.value().toFixed(2) + 'x');
}

// UI styling helpers
function styleLabel(el) {
	el.style('font-family', 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
	el.style('font-size', '14px');
	el.style('color', '#111');
	el.style('line-height', '18px');
}

function styleSlider(el) {
	el.style('width', '180px');
	el.style('accent-color', '#6a0dad');
	el.style('margin', '0');
}

function styleCheckbox(el) {
	el.style('font-family', 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
	el.style('font-size', '14px');
	el.style('color', '#111');
	el.style('line-height', '18px');
}

function pointDistance(point_1, point_2) {
	return sqrt(pow(point_1.x - point_2.x, 2) + pow(point_1.y - point_2.y, 2));
}

class Point {
	constructor(x, y) {
		this.ax = 0;
		this.ay = 0;
		this.vx = 0;
		this.vy = 0;
		this.x = x;
		this.y = y;
	}
}

class Spring {
	constructor(point_1, point_2, k) {
		this.point_1 = point_1;
		this.point_2 = point_2;
		this.mean = pointDistance(point_1, point_2);
		this.k = k;
	}
	
	addAcceleration() {
		let l = pointDistance(this.point_1, this.point_2);
		let delta_l = l - this.mean;
		let a = -this.k * delta_l / this.mean;
		
		let ax = (this.point_1.x - this.point_2.x) / l * a;
		let ay = (this.point_1.y - this.point_2.y) / l * a;
		
		this.point_1.ax += ax;
		this.point_1.ay += ay;
		
		this.point_2.ax -= ax;
		this.point_2.ay -= ay;
		
		//console.log(ax, ay);
	}
}

class ObstacleCircle {
	constructor(x, y, r) {
		this.x = x;
		this.y = y;
		this.r = r;
		// dynamics
		this.vx = 0;
		this.vy = 0;
		this.ax = 0;
		this.ay = 0;
		this.mass = max(1, PI * r * r * OBSTACLE_DENSITY);
	}

	distance(p) {
		return sqrt(pow(p[0]-this.x,2)+pow(p[1]-this.y,2)) - this.r;
	}

	draw() {
		push();
		stroke(0);
		fill(255);
		circle(this.x, this.y, 2 * this.r);
		pop();
	}

	applyForce(fx, fy) {
		this.ax += fx / this.mass;
		this.ay += fy / this.mass;
	}

	contains(px, py) {
		return sqrt(pow(px - this.x, 2) + pow(py - this.y, 2)) <= this.r;
	}
}

// SoftBody encapsulates the blob's geometry and state while preserving existing globals
class SoftBody {
    constructor(innerRadius, outerRadius, vertexCount) {
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.vertexCount = vertexCount;
        this.restOuterArea = 0;
    }

    initializeGeometry() {
        // Keep outer radius fixed; thickness derives from radii
        inner_radius = this.innerRadius;
        outer_radius = this.outerRadius;
        thickness = outer_radius - inner_radius;
        SELF_REPEL_RADIUS = thickness * 1.6;
        // Rebuild using existing initializer to preserve behavior
        initializeBlob(this.vertexCount);
        this.restOuterArea = computeOuterArea();
        // Mirror global for legacy helpers
        restOuterArea = this.restOuterArea;
    }

    rebuildVertexCount(newCount) {
        this.vertexCount = newCount;
        this.initializeGeometry();
    }

    rebuildThickness(targetThickness) {
        // Keep outer fixed, adjust inner inward
        this.innerRadius = max(10, this.outerRadius - targetThickness);
        this.initializeGeometry();
    }
}

function normalizeVec2(p) {
	let m = sqrt(p[0] * p[0] + p[1] * p[1]);
	if (!isFinite(m) || m < 1e-12) {
		return [0, 0];
	}
	return [p[0] / m, p[1] / m];
}

function getNorm(p) {
	let epsilon = 0.001;
	let v = sdf(p);
	return normalizeVec2([sdf([p[0]+epsilon,p[1]])-v,sdf([p[0],p[1]+epsilon])-v]);
}

function sdf_force(p) {
	// If there are no obstacles, there should be no SDF force
	if (obstacles.length === 0) {
		return [0, 0];
	}
	let norm = getNorm(p);
	let factor = min(exp(30 * -sdf(p)), 1000);
	if (!isFinite(norm[0]) || !isFinite(norm[1])) {
		return [0, 0];
	}
	return [factor * norm[0], factor * norm[1]];
}

function getDensityScale() {
	// Reverse polarity mapping so left is high density and right is low density
	// We keep the UI min..max as 0.25..2.0 but interpret as 2.0..0.25
	let v = densitySlider ? densitySlider.value() : 1;
	let dmin = 0.25, dmax = 2.0;
	return dmin + (dmax - dmin) * (1 - (v - dmin) / (dmax - dmin));
}

function updatePhysics() {
	// Reset point acceleration
	for (var i = 0; i < points.length; i++) {
		points[i].ax = 0;
		// gravity scaled by slider and opposed by density (heavier blob feels less net lift)
		let gscale = gravitySlider ? gravitySlider.value() : 1;
		let dscale = getDensityScale();
		points[i].ay = BASE_GRAVITY * gscale / dscale;
		
		let sdf_a = sdf_force([points[i].x, points[i].y]);
		points[i].ax += sdf_a[0];
		points[i].ay += sdf_a[1];
		/*
		points[i].ax = 0;
		points[i].ay = 20;
		if (points[i].y < 0) {
			points[i].ay -= 1000 * points[i].y;
		}
		
		if (points[i].y > size) {
			points[i].ay -= 1000 * (points[i].y - size);
		}
		*/
	}
	
	// Cycle through springs and add to acceleration
	for (var i = 0; i < springs.length; i++) {
		springs[i].addAcceleration();
	}

	// Apply pressure and self-repulsion on the rim to discourage self-wrapping
	applyPressureForces();
	applyRimSelfRepulsion();
	applyRimBending();
	applyRimVelocitySmoothing();
	// Apply obstacle contact friction on outer rim
	applyObstacleFriction();
	// Transfer reaction to obstacles and integrate obstacle motion
	updateObstacleDynamics();

	// Apply mouse spring distributed across a small neighborhood to reduce creasing
	if (draggingBlob && draggedPointIndex >= 0) {
		applyDistributedMouseTug(draggedPointIndex);
	}
	
	// Update position and velocity
	for (var i = 0; i < points.length; i++) {
		let damp = 1;
		points[i].vx += points[i].ax * RATE;
		points[i].vy += points[i].ay * RATE;
		points[i].vx *= exp(damp * -RATE);
		points[i].vy *= exp(damp * -RATE);
		points[i].x += points[i].vx * RATE;
		points[i].y += points[i].vy * RATE;
	}
}

function drawObjects() {
	const showFill = fillCheckbox ? fillCheckbox.checked() : true;
	const showRim = rimCheckbox ? rimCheckbox.checked() : true;
	const showWire = wireCheckbox ? wireCheckbox.checked() : false;
	const showSolid = solidCheckbox ? solidCheckbox.checked() : false;

	// Solid interior first so rims/wires render on top if enabled
	if (showSolid) {
		drawSolidFill();
	}

	// Fill the rim band
	if (showFill) {
		drawRimFill();
	}

	// Wireframe (all springs)
	if (showWire) {
		let centre = points[points.length - 1];
		stroke(0);
		for (var i = 0; i < springs.length; i++) {
			let p1 = springs[i].point_1;
			let p2 = springs[i].point_2;
			if (p1 === centre || p2 === centre) {
				let other = (p1 === centre) ? p2 : p1;
				drawSpokeToHub(other.x, other.y, centre.x, centre.y);
			} else {
				line(p1.x, p1.y, p2.x, p2.y);
			}
		}
		// Optional node dots for clarity
		if (pointsCheckbox ? pointsCheckbox.checked() : false) {
			for (var k = 0; k < points.length; k++) {
				circle(points[k].x, points[k].y, 4);
			}
		}
		// Hub disk for continuity
		drawHub();
	}

	// Border rim (outer ring only)
	if (showRim) {
		stroke(0);
		strokeWeight(2);
		for (var j = 0; j < num_points; j++) {
			let a = points[2 * j + 1];
			let b = points[(2 * ((j + 1) % num_points)) + 1];
			line(a.x, a.y, b.x, b.y);
			if (DRAW_CENTER_SPRINGS) {
				let centre2 = points[points.length - 1];
				drawSpokeToHub(a.x, a.y, centre2.x, centre2.y);
			}
		}
		if (DRAW_CENTER_SPRINGS) {
			drawHub();
		}
		strokeWeight(1);
	}
	// Draw obstacles
	for (var i = 0; i < obstacles.length; i++) {
		obstacles[i].draw();
	}

	// Force vectors (green) from centers of mass
	drawForceVectors();

	// Draw mouse-to-blob tug vectors for the neighborhood while dragging
	if (draggingBlob && draggedPointIndex >= 0) {
		push();
		stroke(0, 255, 0);
		fill(0, 255, 0);
		let isOuter = (draggedPointIndex % 2) === 1;
		let v = Math.floor(draggedPointIndex / 2);
		for (let k = -DRAG_NEIGHBOR_RANGE; k <= DRAG_NEIGHBOR_RANGE; k++) {
			let j = (v + k + num_points) % num_points;
			let idxPrimary = isOuter ? (2 * j + 1) : (2 * j);
			let idxPair = isOuter ? (2 * j) : (2 * j + 1);
			// Primary ring line (thicker)
			strokeWeight(2);
			line(points[idxPrimary].x, points[idxPrimary].y, mouseX, mouseY);
			// Paired ring line (thinner) to show coupled influence
			strokeWeight(1);
			line(points[idxPair].x, points[idxPair].y, mouseX, mouseY);
		}
		// Handle dot at mouse
		circle(mouseX, mouseY, 8);
		pop();
	}
}

// Compute and apply distributed mouse tug around the selected index
function applyDistributedMouseTug(baseIndex) {
	// Determine ring and logical vertex index
	let isOuter = (baseIndex % 2) === 1;
	let v = Math.floor(baseIndex / 2);
	// First pass: accumulate total share so overall force equals the single-point case
	let indices = [];
	let shares = [];
	let totalShare = 0;
	for (let k = -DRAG_NEIGHBOR_RANGE; k <= DRAG_NEIGHBOR_RANGE; k++) {
		let baseW = Math.pow(DRAG_NEIGHBOR_DECAY, Math.abs(k));
		let j = (v + k + num_points) % num_points;
		let idxPrimary = isOuter ? (2 * j + 1) : (2 * j);
		let idxPair = isOuter ? (2 * j) : (2 * j + 1);
		let wPrimary = baseW;
		let wPair = DRAG_PAIR_WEIGHT * baseW;
		indices.push(idxPrimary); shares.push(wPrimary); totalShare += wPrimary;
		indices.push(idxPair);    shares.push(wPair);    totalShare += wPair;
	}
	// Safety
	if (totalShare < 1e-6) totalShare = 1;
	// Second pass: apply proportionally scaled spring+damping to each point
	for (let s = 0; s < indices.length; s++) {
		applyMouseSpringNormalized(indices[s], shares[s], totalShare);
	}
}

function applyMouseSpringNormalized(pointIndex, share, totalShare) {
	let p = points[pointIndex];
	let dx = mouseX - p.x;
	let dy = mouseY - p.y;
	let shareNorm = share / totalShare;
	let fx = (MOUSE_SPRING_K * shareNorm) * dx - (MOUSE_SPRING_DAMP * DRAG_DAMP_MULTIPLIER * shareNorm) * p.vx;
	let fy = (MOUSE_SPRING_K * shareNorm) * dy - (MOUSE_SPRING_DAMP * DRAG_DAMP_MULTIPLIER * shareNorm) * p.vy;
	// Clamp per-point contribution proportionally
	let maxF = MOUSE_MAX_FORCE * shareNorm;
	let fmag = sqrt(fx*fx + fy*fy);
	if (fmag > maxF) {
		let scale = maxF / (fmag + 1e-6);
		fx *= scale;
		fy *= scale;
	}
	p.ax += fx;
	p.ay += fy;
}

function drawRimFill() {
	push();
	noStroke();
	fill(BLOB_FILL_GRAY, BLOB_FILL_GRAY, BLOB_FILL_GRAY, 128);
	beginShape(TRIANGLE_STRIP);
	// Build a triangle strip alternating outer/inner vertices, wrap around to close
	for (var i = 0; i <= num_points; i++) {
		let idx = i % num_points;
		let o = points[2 * idx + 1];
		let inn = points[2 * idx];
		vertex(o.x, o.y);
		vertex(inn.x, inn.y);
	}
	endShape(CLOSE);
	pop();
}

// Solid fill of the entire interior bounded by the outer rim
function drawSolidFill() {
	push();
	noStroke();
	fill(BLOB_FILL_GRAY);
	beginShape();
	for (var i = 0; i < num_points; i++) {
		let o = points[2 * i + 1];
		vertex(o.x, o.y);
	}
	endShape(CLOSE);
	pop();
}

function drawSpokeToHub(x1, y1, cx, cy) {
	let dx = cx - x1;
	let dy = cy - y1;
	let len = sqrt(dx * dx + dy * dy);
	if (len < 1e-6) {
		return;
	}
	let ux = dx / len;
	let uy = dy / len;
	let hx = cx - ux * HUB_RADIUS;
	let hy = cy - uy * HUB_RADIUS;
	line(x1, y1, hx, hy);
}

function drawHub() {
	push();
	noStroke();
	fill(0, 200);
	let c = points[points.length - 1];
	circle(c.x, c.y, HUB_RADIUS * 2);
	pop();
}

// Draw green force vectors from blob center and obstacle centers
function drawForceVectors() {
	push();
	stroke(0, 255, 0);
	fill(0, 255, 0);
	// Blob vector: net force over all points with EMA smoothing
	let c = points[points.length - 1];
	let sumFx = 0, sumFy = 0;
	for (var i = 0; i < points.length; i++) {
		sumFx += points[i].ax; // since ax is acceleration, force ~ a (mass factored in scale)
		sumFy += points[i].ay;
	}
	// EMA smoothing
	blobVisFx = (1 - BLOB_FORCE_EMA) * blobVisFx + BLOB_FORCE_EMA * sumFx;
	blobVisFy = (1 - BLOB_FORCE_EMA) * blobVisFy + BLOB_FORCE_EMA * sumFy;
	let blen = sqrt(blobVisFx*blobVisFx + blobVisFy*blobVisFy);
	let bs = blen * FORCE_VIS_SCALE;
	if (bs > FORCE_VIS_MAX_LEN) bs = FORCE_VIS_MAX_LEN;
	let bux = blen > 0 ? (blobVisFx / blen) : 0;
	let buy = blen > 0 ? (blobVisFy / blen) : 0;
	// draw blob arrow with head
	let bx2 = c.x + bux * bs;
	let by2 = c.y + buy * bs;
	line(c.x, c.y, bx2, by2);
	// arrow head
	let ahx1 = bx2 - bux * ARROW_HEAD_SIZE + (-buy) * (ARROW_HEAD_SIZE * 0.6);
	let ahy1 = by2 - buy * ARROW_HEAD_SIZE + (bux) * (ARROW_HEAD_SIZE * 0.6);
	let ahx2 = bx2 - bux * ARROW_HEAD_SIZE - (-buy) * (ARROW_HEAD_SIZE * 0.6);
	let ahy2 = by2 - buy * ARROW_HEAD_SIZE - (bux) * (ARROW_HEAD_SIZE * 0.6);
	line(bx2, by2, ahx1, ahy1);
	line(bx2, by2, ahx2, ahy2);
	// Obstacles
	for (var i = 0; i < obstacles.length; i++) {
		let o = obstacles[i];
		// Prefer force if present; otherwise show velocity direction to indicate motion
		let ofx = o.ax * o.mass;
		let ofy = o.ay * o.mass;
		let olen = sqrt(ofx*ofx + ofy*ofy);
		let os = olen > 1e-6 ? (olen * FORCE_VIS_SCALE) : (sqrt(o.vx*o.vx + o.vy*o.vy) * VELOCITY_VIS_SCALE);
		if (os > FORCE_VIS_MAX_LEN) os = FORCE_VIS_MAX_LEN;
		let oux, ouy;
		if (olen > 1e-6) {
			oux = ofx / (olen + 1e-6);
			ouy = ofy / (olen + 1e-6);
		} else {
			let vlen = sqrt(o.vx*o.vx + o.vy*o.vy) + 1e-6;
			oux = o.vx / vlen;
			ouy = o.vy / vlen;
		}
		let ox2 = o.x + oux * os;
		let oy2 = o.y + ouy * os;
		line(o.x, o.y, ox2, oy2);
		let oahx1 = ox2 - oux * ARROW_HEAD_SIZE + (-ouy) * (ARROW_HEAD_SIZE * 0.6);
		let oahy1 = oy2 - ouy * ARROW_HEAD_SIZE + (oux) * (ARROW_HEAD_SIZE * 0.6);
		let oahx2 = ox2 - oux * ARROW_HEAD_SIZE - (-ouy) * (ARROW_HEAD_SIZE * 0.6);
		let oahy2 = oy2 - ouy * ARROW_HEAD_SIZE - (oux) * (ARROW_HEAD_SIZE * 0.6);
		line(ox2, oy2, oahx1, oahy1);
		line(ox2, oy2, oahx2, oahy2);
	}
	pop();
}

// Toggle internal cross-section lines with the "i" key; toggle center spokes with "c"
function keyPressed() {
	if (key === 'i' || key === 'I') {
		DRAW_ALL_INTERNAL_SPRINGS = !DRAW_ALL_INTERNAL_SPRINGS;
	}
	if (key === 'c' || key === 'C') {
		DRAW_CENTER_SPRINGS = !DRAW_CENTER_SPRINGS;
	}
}

// Global key handler to catch space bar regardless of focus and clear obstacles
function handleGlobalKeydown(e) {
	if (e.code === 'Space' || e.key === ' ' || e.keyCode === 32) {
		SPAWN_PAUSED = !SPAWN_PAUSED;
		obstacles = [];
		e.preventDefault();
	}
}

function sdf(p) {
	// Combine distances from all obstacles
	if (obstacles.length === 0) {
		return 1e9; // no obstacles
	}
	let d = obstacles[0].distance(p);
	for (var i = 1; i < obstacles.length; i++) {
		d = sdfCombine(d, obstacles[i].distance(p));
	}
	return d;
}

function sdfCombine(d1, d2) {
	if (d1 < 0 && d2 < 0){
		return max(d1, d2);
	} else {
		return min(d1, d2);
	}
}

function sdfCircle(p, o, r) {
	return sqrt(pow(p[0]-o[0],2)+pow(p[1]-o[1],2)) - r;
}

// Approximate blob mass from outer area and density slider
function computeBlobMass() {
	let area = abs(computeOuterArea());
	let density = getDensityScale();
	return max(1, area * BLOB_MASS_PER_AREA * density);
}

// Apply reaction forces from blob to obstacles and integrate obstacle motion
function updateObstacleDynamics() {
	if (obstacles.length === 0) return;
	let blobMass = computeBlobMass();
	// Clear per-step accelerations
	for (var k = 0; k < obstacles.length; k++) {
		obstacles[k].ax = 0;
		obstacles[k].ay = 0;
		if (obstacleDensitySlider) {
			obstacles[k].mass = max(1, PI * obstacles[k].r * obstacles[k].r * OBSTACLE_DENSITY * obstacleDensitySlider.value());
		}
	}
	// If friction is active, transfer tangential reaction from nearby rim points
	let mu = frictionSlider ? frictionSlider.value() : 0;
	if (mu > 0) {
		for (var i = 0; i < num_points; i++) {
			let p = points[2 * i + 1];
			// nearest obstacle
			let nearest = null;
			let minDist = 1e9;
			for (var j = 0; j < obstacles.length; j++) {
				let o = obstacles[j];
				let d = sqrt((p.x - o.x)*(p.x - o.x) + (p.y - o.y)*(p.y - o.y)) - o.r;
				if (d < minDist) { minDist = d; nearest = o; }
			}
			if (!nearest) continue;
			if (minDist < CONTACT_BAND) {
				// geometry
				let dx = p.x - nearest.x;
				let dy = p.y - nearest.y;
				let len = sqrt(dx*dx + dy*dy) + 1e-6;
				let nx = dx / len, ny = dy / len;
				let tx = -ny, ty = nx;
				// tangential velocity of point
				let vt = p.vx * tx + p.vy * ty;
				// reaction magnitude scaled by blob mass and proximity
				let proximity = 1 - max(0, minDist) / CONTACT_BAND;
				let mag = CONTACT_FORCE_FACTOR * blobMass * mu * vt * proximity;
				// Oppose point motion: apply opposite on obstacle
				let fx = -mag * tx;
				let fy = -mag * ty;
				// clamp
				let clampF = MAX_EXTRA_FORCE;
				let fm = sqrt(fx*fx + fy*fy);
				if (fm > clampF) { let s = clampF / (fm + 1e-6); fx *= s; fy *= s; }
				nearest.applyForce(fx, fy);
			}
		}
	}
	// Integrate obstacle motion
	for (var m = 0; m < obstacles.length; m++) {
		let o = obstacles[m];
		// basic damping
		o.vx += o.ax * RATE;
		o.vy += o.ay * RATE;
		o.vx *= exp(-OBSTACLE_DAMPING * RATE);
		o.vy *= exp(-OBSTACLE_DAMPING * RATE);
		o.x += o.vx * RATE;
		o.y += o.vy * RATE;
	}
}

// Apply tangential friction to outer rim points near obstacle surfaces
function applyObstacleFriction() {
	if (!frictionSlider || obstacles.length === 0) return;
	let mu = frictionSlider.value();
	if (mu <= 0) return;
	// Iterate outer vertices only
	for (var i = 0; i < num_points; i++) {
		let p = points[2 * i + 1];
		// Find nearest obstacle and distance
		let nearest = null;
		let minDist = 1e9;
		for (var j = 0; j < obstacles.length; j++) {
			let o = obstacles[j];
			let d = sqrt((p.x - o.x)*(p.x - o.x) + (p.y - o.y)*(p.y - o.y)) - o.r;
			if (d < minDist) { minDist = d; nearest = o; }
		}
		if (!nearest) continue;
		// Engage friction only in a narrow band just outside the surface
		if (minDist < CONTACT_BAND) {
			// Compute surface normal from obstacle center to point
			let dx = p.x - nearest.x;
			let dy = p.y - nearest.y;
			let len = sqrt(dx*dx + dy*dy) + 1e-6;
			let nx = dx / len;
			let ny = dy / len;
			// Tangent unit vector (rotate 90 deg)
			let tx = -ny;
			let ty = nx;
			// Blob point tangential velocity component
			let vt = p.vx * tx + p.vy * ty;
			// Viscous friction: clamp and scale with proximity
			let proximity = 1 - max(0, minDist) / CONTACT_BAND; // 0..1
			let fmag = -mu * vt * proximity;
			// Clamp to prevent blow-ups
			let maxF = MAX_EXTRA_FORCE * 0.4;
			if (fmag >  maxF) fmag =  maxF;
			if (fmag < -maxF) fmag = -maxF;
			// Apply to acceleration
			p.ax += fmag * tx;
			p.ay += fmag * ty;
		}
	}
}

// Mouse interactions for dragging obstacles or the blob via a mouse spring
function mousePressed() {
	for (var i = obstacles.length - 1; i >= 0; i--) {
		if (obstacles[i].contains(mouseX, mouseY)) {
			draggingObstacle = obstacles[i];
			dragOffsetX = mouseX - draggingObstacle.x;
			dragOffsetY = mouseY - draggingObstacle.y;
			break;
		}
	}

	// If not grabbing an obstacle, try to grab the nearest blob point (avoid the centre point)
	if (!draggingObstacle) {
		let minDist2 = 1e18;
		let minIdx = -1;
		for (var i = 0; i < points.length - 1; i++) { // exclude centre (last point)
			let dx = mouseX - points[i].x;
			let dy = mouseY - points[i].y;
			let d2 = dx*dx + dy*dy;
			if (d2 < minDist2) {
				minDist2 = d2;
				minIdx = i;
			}
		}
		if (minIdx >= 0 && sqrt(minDist2) <= outer_radius * 1.5) {
			draggingBlob = true;
			draggedPointIndex = minIdx;
		}
	}
}

function mouseDragged() {
	if (draggingObstacle) {
		draggingObstacle.x = mouseX - dragOffsetX;
		draggingObstacle.y = mouseY - dragOffsetY;
	}
}

function mouseReleased() {
	draggingObstacle = null;
	draggingBlob = false;
	draggedPointIndex = -1;
	// Lock in the current area so pressure forces do not expand after release
	restOuterArea = computeOuterArea();
	if (softBody) softBody.restOuterArea = restOuterArea;
}

// Translate both blob and obstacles upward at a constant rate derived from gravity.
// This creates the illusion of endless falling and is fully decoupled from collisions.
function applyGlobalScroll() {
	let gscale = gravitySlider ? gravitySlider.value() : 1;
	let dy = -BASE_GRAVITY * gscale * RATE; // negative => move up (obstacles rise)
	for (var i = 0; i < points.length; i++) {
		points[i].y += dy;
	}
	for (var j = 0; j < obstacles.length; j++) {
		obstacles[j].y += dy;
	}
}

// Spawn a new obstacle somewhere below the viewport with random radius and x-position
function spawnObstacleBelow() {
	let rmin = CANVAS_SIZE / 24; // half previous min
	let rmax = CANVAS_SIZE / 6;  // half previous max
	let rr = random(rmin, rmax);
	let x = random(CANVAS_SIZE * 0.1, CANVAS_SIZE * 0.9);
	let y = height + rr + random(CANVAS_SIZE * 0.1, CANVAS_SIZE * 0.6);
	return new ObstacleCircle(x, y, rr);
}

// Remove obstacles fully above the frame and replenish from below to keep a steady stream
function recycleObstacles() {
	// Remove any that have moved off the top
	for (var i = obstacles.length - 1; i >= 0; i--) {
		if (obstacles[i].y + obstacles[i].r < 0) {
			obstacles.splice(i, 1);
		}
	}
	// Maintain at least OBSTACLE_COUNT obstacles unless spawning is paused
	if (!SPAWN_PAUSED) {
		while (obstacles.length < OBSTACLE_COUNT) {
			obstacles.push(spawnObstacleBelow());
		}
	}
}

// Compute signed area of outer rim polygon
function computeOuterArea() {
	let area = 0;
	for (var i = 0; i < num_points; i++) {
		let a = points[2 * i + 1];
		let b = points[(2 * ((i + 1) % num_points)) + 1];
		area += a.x * b.y - b.x * a.y;
	}
	return 0.5 * area;
}

// Apply pressure forces proportional to area deviation to preserve shape area
function applyPressureForces() {
	let area = computeOuterArea();
	if (softBody && softBody.restOuterArea !== 0) {
		restOuterArea = softBody.restOuterArea;
	}
	if (restOuterArea === 0) return;
	let rel = (restOuterArea - area) / restOuterArea;
	// Use a slightly stiffer correction only when area is below target to avoid post-drag inflation
	let k = rel > 0 ? PRESSURE_K * 1.25 : PRESSURE_K * 0.6;
	let dscaleP = getDensityScale();
	let pressure = (k * dscaleP) * rel; // heavier blob exerts stronger pressure
	if (pressure === 0) return;

	// Determine outward normal orientation
	let outwardSign = (area > 0) ? 1 : -1; // CCW => outward is right normal

	for (var i = 0; i < num_points; i++) {
		let a = points[2 * i + 1];
		let b = points[(2 * ((i + 1) % num_points)) + 1];
		let ex = b.x - a.x;
		let ey = b.y - a.y;
		let len = sqrt(ex*ex + ey*ey) + 1e-6;
		// Right normal for CCW is (dy, -dx)
		let nx = outwardSign * (ey / len);
		let ny = outwardSign * (-ex / len);
		let f = pressure * len; // distribute along edge length
		// clamp
		let mag = min(abs(f), MAX_PRESSURE_FORCE);
		let fx = mag * Math.sign(f) * nx;
		let fy = mag * Math.sign(f) * ny;
		a.ax += fx * 0.5;
		a.ay += fy * 0.5;
		b.ax += fx * 0.5;
		b.ay += fy * 0.5;
	}
}

// Repel non-adjacent outer rim points that get too close (soft minimum thickness)
function applyRimSelfRepulsion() {
	for (var i = 0; i < num_points; i++) {
		let ai = 2 * i + 1;
		let a = points[ai];
		for (var j = i + 2; j < num_points; j++) { // skip immediate neighbors to avoid fighting the rim springs
			// also skip pair that closes the loop (i and i-1)
			if ((i === 0 && j === num_points - 1)) continue;
			let bi = 2 * j + 1;
			let b = points[bi];
			let dx = b.x - a.x;
			let dy = b.y - a.y;
			let d2 = dx*dx + dy*dy;
			let r = SELF_REPEL_RADIUS;
			if (d2 < r*r) {
				let d = sqrt(d2) + 1e-6;
				let ux = dx / d;
				let uy = dy / d;
				// Soft repulsion grows as they overlap more
				let overlap = 1 - (d / r);
				let mag = SELF_REPEL_STRENGTH * overlap;
				// clamp repulsion
				mag = min(mag, MAX_EXTRA_FORCE);
				let fx = mag * ux;
				let fy = mag * uy;
				// Push them apart equally
				a.ax -= fx;
				a.ay -= fy;
				b.ax += fx;
				b.ay += fy;
			}
		}
	}
}

// Rim bending stiffness: pull each outer point toward average of neighbors
function applyRimBending() {
	for (var i = 0; i < num_points; i++) {
		let prev = (i - 1 + num_points) % num_points;
		let next = (i + 1) % num_points;
		let pPrev = points[2 * prev + 1];
		let pCurr = points[2 * i + 1];
		let pNext = points[2 * next + 1];
		let lapx = pPrev.x + pNext.x - 2 * pCurr.x;
		let lapy = pPrev.y + pNext.y - 2 * pCurr.y;
		let bx = BENDING_K * lapx;
		let by = BENDING_K * lapy;
		// clamp bending force
		let bmag = sqrt(bx*bx + by*by);
		if (bmag > MAX_EXTRA_FORCE) {
			let s = MAX_EXTRA_FORCE / (bmag + 1e-6);
			bx *= s;
			by *= s;
		}
		pCurr.ax += bx;
		pCurr.ay += by;
	}
}

// Viscous velocity smoothing along the rim to damp sharp creasing
function applyRimVelocitySmoothing() {
	for (var i = 0; i < num_points; i++) {
		let prev = (i - 1 + num_points) % num_points;
		let next = (i + 1) % num_points;
		let pPrev = points[2 * prev + 1];
		let pCurr = points[2 * i + 1];
		let pNext = points[2 * next + 1];
		let vLapx = pPrev.vx + pNext.vx - 2 * pCurr.vx;
		let vLapy = pPrev.vy + pNext.vy - 2 * pCurr.vy;
		pCurr.vx += VISC_BEND_COEF * vLapx * RATE;
		pCurr.vy += VISC_BEND_COEF * vLapy * RATE;
	}
}

// Rebuild blob points and springs with a given outer-rim vertex count
function initializeBlob(newNumPoints) {
	points = [];
	springs = [];
	num_points = newNumPoints;
	// Points
	for (var i = 0; i < num_points; i++) {
		points.push(new Point(width/2 + inner_radius * cos(2 * PI * i / num_points), height/2 + inner_radius * sin(2 * PI * i / num_points)));
		points.push(new Point(width/2 + outer_radius * cos(2 * PI * i / num_points), height/2 + outer_radius * sin(2 * PI * i / num_points)));
	}
	points.push(new Point(width/2, height/2));
	let centre = points[points.length - 1];
	// Springs
	for (var i = 0; i < num_points; i++) {
		springs.push(new Spring(points[2 * i], points[2 * i + 1], OUTER_RIM_K));
		springs.push(new Spring(points[2 * i + 1], points[(2 * i + 2) % (2 * num_points)], OUTER_RIM_K));
		springs.push(new Spring(points[2 * i], points[(2 * i + 3) % (2 * num_points)], OUTER_RIM_K));
		springs.push(new Spring(points[2 * i], points[(2 * i + 2) % (2 * num_points)], OUTER_RIM_K));
		springs.push(new Spring(points[2 * i + 1], points[(2 * i + 3) % (2 * num_points)], OUTER_RIM_K));
		// Bend springs on outer rim
		springs.push(new Spring(
			points[2 * i + 1],
			points[(2 * ((i + 2) % num_points)) + 1],
			BEND_SPRING_K
		));
		// Spokes to centre
		springs.push(new Spring(points[2 * i], centre, INNER_SPOKE_K));
		springs.push(new Spring(points[2 * i + 1], centre, INNER_SPOKE_K));
	}
	if (ADD_RANDOM_CROSS_SPRINGS) {
		for (var r = 0; r < 100; r++) {
			let n1 = Math.floor(2 * num_points * Math.random());
			let n2 = Math.floor(2 * num_points * Math.random());
			if (n1 != n2) {
				springs.push(new Spring(points[n1], points[n2], INNER_SPOKE_K));
			}
		}
	}
}

    </script>
  </body>
</html>
