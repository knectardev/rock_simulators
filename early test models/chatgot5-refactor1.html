<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2D Soft-Body Blob — Cleaner Physics Sliders</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    :root { --panel: rgba(0,0,0,.82); }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif; color: #eee; background:#1b1b1b; overflow:hidden;
    }
    #container { position: relative; width:100vw; height:100vh; }
    #controls {
      position:absolute; inset:10px auto auto 10px; z-index:10; background:var(--panel); border-radius:12px; padding:14px; width:320px; box-shadow:0 4px 18px rgba(0,0,0,.4);
    }
    h3 { margin:0 0 10px 0; font-size:14px; letter-spacing:.3px; color:#fff; }
    .row { display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row label { flex: 0 0 160px; font-size:12px; color:#cfcfcf; }
    .row input[type=range] { flex:1 1 auto; }
    .val { font-size:11px; color:#9ad; width:44px; text-align:right; }
    .buttons { display:flex; gap:8px; margin-top:10px; }
    button { background:#2b6; border:0; color:white; padding:7px 10px; border-radius:8px; cursor:pointer; font-size:12px; }
    button:disabled { background:#666; cursor:not-allowed; }
    #info { position:absolute; left:10px; bottom:10px; font-size:11px; color:#9aa; }
    #palette { position:absolute; right:10px; top:10px; z-index:12; background:var(--panel); padding:12px; border-radius:12px; width:200px; }
    #palette h3{ margin:0 0 8px 0; }
    .palette-item{ display:flex; gap:8px; align-items:center; background:#0f0f0f; border:1px solid #333; border-radius:10px; padding:8px; margin:8px 0; cursor:grab; }
    .palette-icon{ width:34px; height:34px; display:inline-block; }
    .icon-circle{ border-radius:50%; border:2px solid #ffd166; }
    .icon-square{ border:2px solid #06d6a0; }
    .icon-triangle{ width:0; height:0; border-left:17px solid transparent; border-right:17px solid transparent; border-bottom:30px solid #118ab2; background:none; }
  </style>
</head>
<body>
<div id="container">
  <div id="controls">
    <h3>Physically Cleaner Controls</h3>

    <!-- ENVIRONMENT / SCALE -->
    <div class="row"><label>Gravity (m/s²)</label><input id="gravity" type="range" min="0" max="20" step="0.1" value="9.8"><span class="val" id="gravity_v">9.8</span></div>
    <div class="row"><label>Total Mass (kg, distributed)</label><input id="mass" type="range" min="0.2" max="8" step="0.1" value="2.0"><span class="val" id="mass_v">2.0</span></div>
    <div class="row"><label>Node Density</label><input id="nodeDensity" type="range" min="5" max="18" step="1" value="10"><span class="val" id="nodeDensity_v">10</span></div>

    <hr style="border:0;border-top:1px solid #333; margin:10px 0" />

    <!-- INTRINSIC (BULK) -->
    <div class="row"><label>Elasticity → Spring Stiffness</label><input id="stiffness" type="range" min="0.05" max="0.95" step="0.01" value="0.6"><span class="val" id="stiffness_v">0.60</span></div>
    <div class="row"><label>Viscosity → Spring Damping</label><input id="damping" type="range" min="0" max="0.35" step="0.005" value="0.08"><span class="val" id="damping_v">0.08</span></div>
    <div class="row"><label>Air Drag (linear)</label><input id="airDrag" type="range" min="0" max="0.03" step="0.001" value="0.006"><span class="val" id="airDrag_v">0.006</span></div>

    <div class="row"><label>Pressure Gain (area preservation)</label><input id="pressureGain" type="range" min="0" max="0.015" step="0.0005" value="0.004"><span class="val" id="pressureGain_v">0.004</span></div>

    <hr style="border:0;border-top:1px solid #333; margin:10px 0" />

    <!-- CONTACT (EXTRINSIC) -->
    <div class="row"><label>Blob Restitution (bounce)</label><input id="blobRestitution" type="range" min="0" max="1" step="0.01" value="0.25"><span class="val" id="blobRestitution_v">0.25</span></div>
    <div class="row"><label>Blob Contact Friction</label><input id="blobFriction" type="range" min="0" max="1" step="0.01" value="0.3"><span class="val" id="blobFriction_v">0.30</span></div>

    <div class="row"><label>Ground/Obstacle Friction</label><input id="groundFriction" type="range" min="0" max="1" step="0.01" value="0.5"><span class="val" id="groundFriction_v">0.50</span></div>
    <div class="row"><label>Ground/Obstacle Restitution</label><input id="groundRestitution" type="range" min="0" max="1" step="0.01" value="0.1"><span class="val" id="groundRestitution_v">0.10</span></div>

    <hr style="border:0;border-top:1px solid #333; margin:10px 0" />

    <!-- MISC -->
    <div class="row"><label>Animation Speed</label><input id="animSpeed" type="range" min="0.1" max="3" step="0.1" value="1"><span class="val" id="animSpeed_v">1.0</span></div>
    <div class="buttons">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <div id="palette">
    <h3>Obstacle Palette</h3>
    <div class="palette-item" draggable="true" data-shape="circle" data-size="60"><span class="palette-icon icon-circle"></span><span>Circle</span></div>
    <div class="palette-item" draggable="true" data-shape="square" data-size="70"><span class="palette-icon icon-square"></span><span>Square</span></div>
    <div class="palette-item" draggable="true" data-shape="triangle" data-size="80"><span class="palette-icon icon-triangle"></span><span>Triangle</span></div>
    <div style="font-size:11px;color:#bbb;margin-top:6px;">Drag shapes onto the box</div>
  </div>

  <div id="info">Soft body with spring–damper + pressure | FPS: <span id="fps">60</span></div>
</div>

<script>
class CleanBlobSim {
  constructor() {
    this.boxW = 1000; this.boxH = 600; this.radius = 100;

    this.params = {
      gravity: 9.8,
      mass: 2.0,
      nodeDensity: 10,
      stiffness: 0.6,
      damping: 0.08,
      airDrag: 0.006,
      pressureGain: 0.004,
      blobRestitution: 0.25,
      blobFriction: 0.3,
      groundFriction: 0.5,
      groundRestitution: 0.1,
      animSpeed: 1.0,
    };

    this._initThree();
    this._initMatter();
    this._initControls();
    this._initPalette();

    this._makeBox();
    this._makeBlob();

    this.obstacles = [];

    this.isRunning = false;
    this.isPaused = false;

    this._lastTime = performance.now();
    this._fpsCount = 0; this._lastFPSStamp = performance.now();
    this._accum = 0; // accumulator for fixed-step substepping

    this._animate();
  }

  _initThree(){
    this.scene = new THREE.Scene();
    this.camera = new THREE.OrthographicCamera(-this.boxW/2, this.boxW/2, this.boxH/2, -this.boxH/2, 1, 1000);
    this.camera.position.z = 100;
    this.renderer = new THREE.WebGLRenderer({ antialias:true });
    this.renderer.setSize(this.boxW, this.boxH);
    this.renderer.setClearColor(0x222222);
    const dom = this.renderer.domElement;
    dom.style.position='absolute'; dom.style.left='50%'; dom.style.top='50%'; dom.style.transform='translate(-50%,-50%)'; dom.style.zIndex='1';
    document.getElementById('container').appendChild(dom);
    const amb = new THREE.AmbientLight(0xffffff, .6); this.scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff,.8); dir.position.set(0,0,200); this.scene.add(dir);
  }

  _initMatter(){
    this.engine = Matter.Engine.create();
    this.world = this.engine.world;
    // Matter uses +y down, Three.js visual uses +y up. Use negative gravity so visuals fall downward.
    // Scale gravity slightly to keep speeds reasonable for a 600px world
    this.world.gravity.y = -this.params.gravity/10;
    this.world.gravity.scale = 0.001; // keeps numeric stability
    this.engine.positionIterations = 12; this.engine.velocityIterations = 12; this.engine.constraintIterations = 6;
    this.engine.enableSleeping = false;
  }

  _initControls(){
    const ids = [
      'gravity','mass','nodeDensity','stiffness','damping','airDrag','pressureGain',
      'blobRestitution','blobFriction','groundFriction','groundRestitution','animSpeed'
    ];
    for(const id of ids){
      const el = document.getElementById(id);
      const v = document.getElementById(id+'_v');
      const fmt = (x)=> (id==='stiffness'||id==='blobRestitution'||id==='blobFriction'||id==='groundFriction'||id==='groundRestitution'||id==='animSpeed')? (+x).toFixed(2) : (+x).toString();
      if(el){
        v && (v.textContent = fmt(el.value));
        el.addEventListener('input', (e)=>{
          const val = parseFloat(e.target.value);
          this.params[id] = val;
          v && (v.textContent = fmt(val));
          this._applyLiveUpdates(id);
        });
      }
    }

    document.getElementById('startBtn').addEventListener('click', ()=>{ this.isRunning=true; this.isPaused=false; this._updateButtons(); });
    document.getElementById('pauseBtn').addEventListener('click', ()=>{ this.isPaused=true; this._updateButtons(); });
    document.getElementById('resetBtn').addEventListener('click', ()=>{ this._reset(); });
  }

  _updateButtons(){
    document.getElementById('startBtn').disabled = this.isRunning && !this.isPaused;
    document.getElementById('pauseBtn').disabled = !this.isRunning || this.isPaused;
  }

  _applyLiveUpdates(id){
    if(id==='gravity'){
      // Keep Three.js visual downwards by applying negative gravity in Matter
      this.world.gravity.y = -this.params.gravity/10;
    }
    if(id==='nodeDensity'){
      this._makeBlob();
      return;
    }
    if(['mass'].includes(id)){
      this._updateNodeMasses();
    }
    if(['stiffness','damping','airDrag','blobRestitution','blobFriction'].includes(id)){
      this._applyBlobMaterials();
    }
    if(['groundFriction','groundRestitution'].includes(id)){
      this._applyEnvironmentMaterials();
    }
  }

  _initPalette(){
    const dom = this.renderer.domElement;
    document.querySelectorAll('.palette-item').forEach(el=>{
      el.addEventListener('dragstart', (ev)=>{
        ev.dataTransfer.setData('text/plain', JSON.stringify({
          shape: el.getAttribute('data-shape'), size: parseFloat(el.getAttribute('data-size')||'60')
        }));
        ev.dataTransfer.effectAllowed='copy';
      });
    });
    dom.addEventListener('dragover', (ev)=>{ ev.preventDefault(); ev.dataTransfer.dropEffect='copy'; });
    dom.addEventListener('drop', (ev)=>{
      ev.preventDefault();
      const t = ev.dataTransfer.getData('text/plain'); if(!t) return; let d; try{ d=JSON.parse(t);}catch{ return; }
      const p = this._screenToWorld(ev.clientX, ev.clientY);
      if(Math.abs(p.x) > this.boxW/2 - 20 || Math.abs(p.y) > this.boxH/2 - 20) return;
      this._addObstacle(d.shape, d.size, p.x, p.y);
    });
  }

  _screenToWorld(cx, cy){
    const rect = this.renderer.domElement.getBoundingClientRect();
    const xN = ((cx - rect.left)/rect.width)*2 - 1;
    const yN = -((cy - rect.top)/rect.height)*2 + 1;
    const ray = new THREE.Raycaster(); ray.setFromCamera({x:xN,y:yN}, this.camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,0,1),0); const hit = new THREE.Vector3();
    ray.ray.intersectPlane(plane, hit); return hit;
  }

  _makeBox(){
    const mat = new THREE.LineBasicMaterial({ color:0x00ff7f });
    const g = new THREE.BufferGeometry();
    // Draw the outline at the actual collision surfaces (inset by half wall thickness = 10)
    const inset = 10;
    const v = new Float32Array([
      -this.boxW/2+inset, -this.boxH/2+inset, 0,   this.boxW/2-inset, -this.boxH/2+inset, 0,
       this.boxW/2-inset,  this.boxH/2-inset, 0,  -this.boxW/2+inset,  this.boxH/2-inset, 0,
      -this.boxW/2+inset, -this.boxH/2+inset, 0,
    ]);
    g.setAttribute('position', new THREE.BufferAttribute(v,3));
    this.scene.add(new THREE.Line(g, mat));

    const wallOpt = { isStatic:true, friction:this.params.groundFriction, frictionStatic:Math.min(1,this.params.groundFriction+0.2), restitution:this.params.groundRestitution };
    const ground = Matter.Bodies.rectangle(0, -this.boxH/2+10, this.boxW, 20, wallOpt);
    const left   = Matter.Bodies.rectangle(-this.boxW/2+10, 0, 20, this.boxH, wallOpt);
    const right  = Matter.Bodies.rectangle( this.boxW/2-10, 0, 20, this.boxH, wallOpt);
    const ceil   = Matter.Bodies.rectangle(0,  this.boxH/2-10, this.boxW, 20, wallOpt);
    Matter.World.add(this.world, [ground,left,right,ceil]);
    this.walls = {ground,left,right,ceil};
  }

  _applyEnvironmentMaterials(){
    const apply = (b)=>{ b.friction=this.params.groundFriction; b.frictionStatic=Math.min(1,this.params.groundFriction+0.2); b.restitution=this.params.groundRestitution; };
    if(this.walls){ for(const k of Object.keys(this.walls)) apply(this.walls[k]); }
    if(this.obstacles){ for(const ob of this.obstacles){ if(ob.body) apply(ob.body); } }
  }

  _addObstacle(shape, size, x, y){
    const common = { isStatic:true, friction:this.params.groundFriction, frictionStatic:Math.min(1,this.params.groundFriction+0.2), restitution:this.params.groundRestitution };
    let body=null, mesh=null, outline=null;
    if(shape==='circle'){
      const r = Math.max(10, size*0.5);
      body = Matter.Bodies.circle(x,y,r, common);
      const geom = new THREE.CircleGeometry(r,48);
      mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color:0xffd166, transparent:true, opacity:.25 }));
      outline = new THREE.LineLoop(new THREE.EdgesGeometry(new THREE.CircleGeometry(r,48)), new THREE.LineBasicMaterial({ color:0xffd166 })); mesh.add(outline);
    } else if(shape==='square'){
      const half = Math.max(12, size*0.5);
      body = Matter.Bodies.rectangle(x,y, half*2, half*2, common);
      const geom = new THREE.PlaneGeometry(half*2, half*2);
      mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color:0x06d6a0, transparent:true, opacity:.25, side:THREE.DoubleSide }));
      outline = new THREE.LineSegments(new THREE.EdgesGeometry(geom), new THREE.LineBasicMaterial({ color:0x06d6a0 })); mesh.add(outline);
    } else {
      const r = Math.max(14, size*0.6);
      const verts = [ {x:0,y:-r}, {x:-(Math.sqrt(3)/2)*r, y:r/2}, {x:(Math.sqrt(3)/2)*r, y:r/2} ];
      const worldVerts = verts.map(p=>({x:x+p.x, y:y+p.y}));
      body = Matter.Bodies.fromVertices(x,y,[worldVerts], common);
      const geom = new THREE.BufferGeometry(); const arr = new Float32Array([0,-r,0,  -(Math.sqrt(3)/2)*r,r/2,0,  (Math.sqrt(3)/2)*r,r/2,0]);
      geom.setAttribute('position', new THREE.BufferAttribute(arr,3)); geom.setIndex([0,1,2]);
      mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color:0x118ab2, transparent:true, opacity:.25, side:THREE.DoubleSide }));
      const lg = new THREE.BufferGeometry(); const la = new Float32Array([0,-r,0,  -(Math.sqrt(3)/2)*r,r/2,0,  (Math.sqrt(3)/2)*r,r/2,0, 0,-r,0]);
      lg.setAttribute('position', new THREE.BufferAttribute(la,3)); outline = new THREE.Line(lg, new THREE.LineBasicMaterial({ color:0x118ab2 })); mesh.add(outline);
    }
    mesh.position.set(x,y,0); this.scene.add(mesh); Matter.World.add(this.world, body);
    this.obstacles.push({ body, mesh, outline, shape });
  }

  _makeBlob(){
    this._clearBlob();

    const nodes = []; const nodeMeshes = []; const edges = [];

    // create nodes on a jittered disk
    const N = this.params.nodeDensity; const spacing = this.radius*2 / N;
    const startY = this.boxH/2 - 140; // start near top visually
    const center = { x: 0, y: startY };

    const nodeMat = new THREE.MeshBasicMaterial({ color:0xff5555 });
    const nodeGeom = new THREE.SphereGeometry(3, 8, 8);

    const group = Matter.Body.nextGroup(true); // avoid self-collisions

    const jitter = Math.min(4, spacing*0.12);
    for(let i=0;i<N;i++){
      for(let j=0;j<N;j++){
        const x = -this.radius + i*spacing;
        const y = startY - this.radius + j*spacing;
        const dx = x - center.x, dy = y - center.y; const r = Math.hypot(dx,dy);
        if(r <= this.radius){
          const jx = (Math.random()*2-1)*jitter; const jy = (Math.random()*2-1)*jitter;
          const body = Matter.Bodies.circle(x+jx, y+jy, 4, {
            friction: this.params.blobFriction,
            frictionStatic: Math.min(1, this.params.blobFriction+0.2),
            restitution: this.params.blobRestitution,
            frictionAir: this.params.airDrag,
            collisionFilter: { group }
          });
          nodes.push(body);
          const mesh = new THREE.Mesh(nodeGeom, nodeMat); mesh.position.set(body.position.x, body.position.y, 0); this.scene.add(mesh); nodeMeshes.push(mesh);
        }
      }
    }

    // connect neighbors with springs
    const neighborDist = spacing*1.8;
    const lines = []; const lineMat = new THREE.LineBasicMaterial({ color:0x444488, transparent:true, opacity:.6 });
    for(let i=0;i<nodes.length;i++){
      for(let j=i+1;j<nodes.length;j++){
        const a = nodes[i], b = nodes[j];
        const dx=a.position.x-b.position.x, dy=a.position.y-b.position.y; const d=Math.hypot(dx,dy);
        if(d < neighborDist){
          const c = Matter.Constraint.create({ bodyA:a, bodyB:b, length:d, stiffness:this.params.stiffness, damping:this.params.damping });
          edges.push(c);
          const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6),3));
          const line = new THREE.Line(g, lineMat); this.scene.add(line); lines.push(line);
        }
      }
    }

    Matter.World.add(this.world, [...nodes, ...edges]);

    this.blob = {
      nodes, nodeMeshes, edges, lines,
      targetArea: 0, // set after first hull
    };

    this._updateNodeMasses();
    this._applyBlobMaterials();

    // visual hull line
    const hullMat = new THREE.LineBasicMaterial({ color:0x00ffff });
    this.hullLine = new THREE.Line(new THREE.BufferGeometry(), hullMat); this.scene.add(this.hullLine);

    // initialize target area from initial hull
    this._updateVisualsAndHull();
    this.blob.targetArea = Math.max(1, this._polyArea(this.hullPts||[]));
  }

  _clearBlob(){
    if(!this.blob) return;
    Matter.World.remove(this.world, [...this.blob.nodes, ...this.blob.edges]);
    for(const m of this.blob.nodeMeshes) this.scene.remove(m);
    for(const l of this.blob.lines) this.scene.remove(l);
    if(this.hullLine) this.scene.remove(this.hullLine);
    this.blob = null; this.hullLine = null;
  }

  _updateNodeMasses(){
    if(!this.blob) return; const m = Math.max(0.0001, this.params.mass/this.blob.nodes.length);
    for(const n of this.blob.nodes) Matter.Body.setMass(n, m);
  }

  _applyBlobMaterials(){
    if(!this.blob) return;
    for(const n of this.blob.nodes){
      n.friction = this.params.blobFriction;
      n.frictionStatic = Math.min(1, this.params.blobFriction+0.2);
      n.restitution = this.params.blobRestitution;
      n.frictionAir = this.params.airDrag;
    }
    for(const c of this.blob.edges){ c.stiffness = this.params.stiffness; c.damping = this.params.damping; }
  }

  _computeHull(points){
    // Monotone chain convex hull (enough for pressure/area preservation; can be swapped for alpha-shape if needed)
    if(points.length < 3) return points.slice();
    const pts = points.slice().sort((a,b)=> a.x===b.x ? a.y-b.y : a.x-b.x);
    const cross=(o,a,b)=> (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);
    const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
    const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
    upper.pop(); lower.pop(); return lower.concat(upper);
  }

  _polyArea(pts){
    let A=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; A += p.x*q.y - p.y*q.x; } return Math.abs(A)*0.5;
  }

  _applyPressureForce(){
    if(!this.blob || !this.hullPts || this.hullPts.length<3) return;
    const curArea = Math.max(1, this._polyArea(this.hullPts));
    const target = this.blob.targetArea || curArea;
    const areaError = (target - curArea) / target; // positive if compressed
    const gain = this.params.pressureGain; if(gain<=0) return;
    const pressure = gain * areaError; // signed scalar

    // Build a map node -> accumulated force
    const nodeIndex = new Map(); this.blob.nodes.forEach((n, i)=> nodeIndex.set(n, i));
    const accum = new Array(this.blob.nodes.length).fill(0).map(()=>({x:0,y:0}));

    // For each hull edge, push outward normal * edge length * pressure
    const H = this.hullPts.length;
    for(let i=0;i<H;i++){
      const a = this.hullPts[i];
      const b = this.hullPts[(i+1)%H];
      const edge = { x: b.x-a.x, y: b.y-a.y };
      const len = Math.hypot(edge.x, edge.y) || 1;
      // outward normal for CCW hull points: (nx, ny) = (edge.y/len, -edge.x/len)
      const nx =  edge.y/len, ny = -edge.x/len;
      const Fx = pressure * len * nx;
      const Fy = pressure * len * ny;
      // distribute half to each incident node (nearest physical node: find closest blobs)
      const ia = this._closestNodeIndex(a), ib = this._closestNodeIndex(b);
      if(ia>=0){ accum[ia].x += Fx*0.5; accum[ia].y += Fy*0.5; }
      if(ib>=0){ accum[ib].x += Fx*0.5; accum[ib].y += Fy*0.5; }
    }

    // apply forces
    // Clamp per-node pressure to avoid instability near contacts
    const perNodeMass = Math.max(0.0001, this.params.mass / this.blob.nodes.length);
    const gMag = Math.abs(this.world?.gravity?.y || 1);
    const fMax = 0.5 * perNodeMass * (gMag + 1); // tuned cap
    for(let i=0;i<accum.length;i++){
      const n = this.blob.nodes[i]; const f = accum[i];
      const mag = Math.hypot(f.x, f.y);
      if(mag > fMax){ const s = fMax/(mag||1); f.x*=s; f.y*=s; }
      if(f.x||f.y) Matter.Body.applyForce(n, n.position, f);
    }
  }

  _closestNodeIndex(p){
    if(!this.blob) return -1; let best=-1, bd=1e9;
    for(let i=0;i<this.blob.nodes.length;i++){
      const n=this.blob.nodes[i]; const dx=n.position.x-p.x, dy=n.position.y-p.y; const d=dx*dx+dy*dy; if(d<bd){bd=d; best=i;}
    }
    return best;
  }

  _updateVisualsAndHull(){
    if(!this.blob) return;
    // nodes
    for(let i=0;i<this.blob.nodes.length;i++){
      const n=this.blob.nodes[i]; this.blob.nodeMeshes[i].position.set(n.position.x, n.position.y, 0);
    }
    // edges
    for(let k=0;k<this.blob.edges.length;k++){
      const c=this.blob.edges[k]; const arr=this.blob.lines[k].geometry.attributes.position.array;
      arr[0]=c.bodyA.position.x; arr[1]=c.bodyA.position.y; arr[2]=0;
      arr[3]=c.bodyB.position.x; arr[4]=c.bodyB.position.y; arr[5]=0; this.blob.lines[k].geometry.attributes.position.needsUpdate=true;
    }
    // hull (convex for stability)
    const pts = this.blob.nodes.map(n=>({x:n.position.x,y:n.position.y}));
    this.hullPts = this._computeHull(pts);
    const hv = [];
    for(const p of this.hullPts){ hv.push(p.x,p.y,0); }
    if(this.hullPts.length){ hv.push(this.hullPts[0].x, this.hullPts[0].y, 0); }
    const pos = new Float32Array(hv);
    this.hullLine.geometry.setAttribute('position', new THREE.BufferAttribute(pos,3));
    this.hullLine.geometry.attributes.position.needsUpdate=true;
  }

  _animate(){
    requestAnimationFrame(()=>this._animate());
    const now = performance.now(); const dt = (now - this._lastTime)/1000; this._lastTime = now;

    // FPS
    this._fpsCount++; if(now - this._lastFPSStamp >= 1000){
      document.getElementById('fps').textContent = Math.round((this._fpsCount*1000)/(now - this._lastFPSStamp));
      this._fpsCount=0; this._lastFPSStamp=now;
    }

    if(this.isRunning && !this.isPaused){
      const fixed = (1/120); // 120 Hz physics for better collision stability
      const maxFrame = 1/20; // prevent spiral of death
      const clampedDt = Math.min(dt * this.params.animSpeed, maxFrame);
      this._accum += clampedDt;

      const maxSubsteps = 8; let steps = 0;
      while(this._accum >= fixed && steps < maxSubsteps){
        // Pressure/area preservation before each substep
        this._updateVisualsAndHull();
        this._applyPressureForce();
        Matter.Engine.update(this.engine, fixed*1000);
        this._accum -= fixed; steps++;
      }

      // resync visuals after steps
      this._updateVisualsAndHull();
      // obstacles sync
      if(this.obstacles){ for(const ob of this.obstacles){ if(ob.body&&ob.mesh){ ob.mesh.position.set(ob.body.position.x, ob.body.position.y, 0); ob.mesh.rotation.z = ob.body.angle; if(ob.outline) ob.outline.rotation.z = ob.mesh.rotation.z; } } }
    }

    this.renderer.render(this.scene, this.camera);
  }

  _reset(){
    this.isRunning=false; this.isPaused=false; this._updateButtons();
    // remove obstacles
    if(this.obstacles && this.obstacles.length){ for(const ob of this.obstacles){ if(ob.mesh) this.scene.remove(ob.mesh); if(ob.body) Matter.World.remove(this.world, ob.body);} this.obstacles=[]; }
    this._makeBlob();
  }
}

window.addEventListener('load', ()=>{ window.sim = new CleanBlobSim(); });
</script>
</body>
</html>
