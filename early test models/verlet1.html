<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Verlet Blob (Canvas, draggable) â€” Gravity & Gooiness</title>
<style>
  html, body { margin:0; height:100%; background:#14161a; color:#e8e8ea; font:14px/1.3 system-ui, Segoe UI, Roboto, Arial; }
  canvas { display:block; margin:0 auto; background:#14161a; }
  .ui {
    position: fixed; inset: 12px auto auto 12px; background:#1b1e24cc; border:1px solid #323640;
    border-radius:12px; padding:10px 12px; backdrop-filter: blur(3px);
  }
  .row{ display:flex; align-items:center; gap:10px; margin:6px 0; }
  .row label{ width:80px; color:#bfc6d4; }
  .val{ width:34px; text-align:right; color:#fff }
  input[type=range]{ width:220px; }
  .hint{ color:#93a0b5; margin-top:6px; font-size:12px }
</style>
</head>
<body>
<div class="ui">
  <div class="row">
    <label>Gravit2y</label>
    <input id="gravity" type="range" min="0" max="10000" value="3000" step="10">
    <div class="val" id="gVal">3000</div>
  </div>
  <div class="row">
    <label>Gooiness</label>
    <input id="goo" type="range" min="1" max="10" value="6" step="1">
    <div class="val" id="gooVal">6</div>
  </div>
  <div class="hint">Drag/throw the blob. Gooiness: <b>1</b> = puddle, <b>10</b> = wild bouncer.</div>
</div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = Math.min(window.innerWidth, 1200);
canvas.height = Math.min(window.innerHeight, 800);

const W = canvas.width;
const H = canvas.height;
const bounds = { l:40, r:W-40, t:40, b:H-40 };

// UI refs
const gravitySlider = document.getElementById('gravity');
const gravityVal = document.getElementById('gVal');
const gooSlider = document.getElementById('goo');
const gooVal = document.getElementById('gooVal');

// Ensure useful slider ranges regardless of HTML defaults
(function initUI(){
  gravitySlider.min = 0; gravitySlider.max = 6000; gravitySlider.step = 10;
  if (!gravitySlider.value || parseFloat(gravitySlider.value) < 100) gravitySlider.value = 2000;
  gravityVal.textContent = gravitySlider.value;
  // clarify hint if present
  const hint = document.querySelector('.hint');
  if (hint) hint.innerHTML = 'Drag/throw the blob. Gooiness: <b>1</b> = puddle-like (very melty, minimal bounce), <b>10</b> = very firm & bouncy.';
})();

let GRAVITY = parseFloat(gravitySlider.value);
let ITERATIONS = 10;     // more iterations for stability at high bounce
let SUBSTEPS = 3;        // extra substeps for stronger gravity

// Data
const nodes = [];
const edges = [];
let perimeter = [];
let originalArea = 0;
let spacing = 18;

function buildBlob(){
  nodes.length=0; edges.length=0; perimeter.length=0;
  const cols=9, rows=7; spacing=18;
  const startX=W*0.5, startY=H*0.2; // start high so it drops
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const px=startX+(x-cols/2)*spacing;
      const py=startY+(y-rows/2)*spacing;
      nodes.push({x:px,y:py,oldx:px,oldy:py,pinned:false});
    }
  }
  const idx=(x,y)=>y*cols+x;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      if(x+1<cols) addEdge(idx(x,y),idx(x+1,y),spacing,1.0);
      if(y+1<rows) addEdge(idx(x,y),idx(x,y+1),spacing,1.0);
      if(x+1<cols&&y+1<rows){
        addEdge(idx(x,y),idx(x+1,y+1),Math.SQRT2*spacing,0.7);  // shear
        addEdge(idx(x+1,y),idx(x,y+1),Math.SQRT2*spacing,0.7);
      }
      // longer-range bend constraints help shape at high bounce
      if(x+2<cols) addEdge(idx(x,y),idx(x+2,y),2*spacing,0.5);
      if(y+2<rows) addEdge(idx(x,y),idx(x,y+2),2*spacing,0.5);
    }
  }
  // Perimeter walk
  for (let x=0; x<cols; x++) perimeter.push(idx(x,0));
  for (let y=1; y<rows; y++) perimeter.push(idx(cols-1,y));
  for (let x=cols-2; x>=0; x--) perimeter.push(idx(x,rows-1));
  for (let y=rows-2; y>0; y--) perimeter.push(idx(0,y));

  originalArea = polygonArea(perimeter.map(i => ({x:nodes[i].x, y:nodes[i].y})));
}

function addEdge(i,j,rest,k=1.0){ edges.push({i,j,rest,k}); }
function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){const p=pts[i],q=pts[(i+1)%pts.length]; a+=(p.x*q.y-q.x*p.y);} return 0.5*a; }

// Picking / dragging
let dragIdx=-1, lastMouse={x:0,y:0}, mouseVel={x:0,y:0};
canvas.addEventListener('mousedown',e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  dragIdx=pickNearestNode(mx,my,25);
  lastMouse={x:mx,y:my}; mouseVel={x:0,y:0};
});
canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  if(dragIdx>=0){mouseVel={x:mx-lastMouse.x,y:my-lastMouse.y};}
  lastMouse={x:mx,y:my};
});
canvas.addEventListener('mouseup',()=>{
  if(dragIdx>=0){
    nodes[dragIdx].oldx=nodes[dragIdx].x-mouseVel.x;
    nodes[dragIdx].oldy=nodes[dragIdx].y-mouseVel.y;
  }
  dragIdx=-1;
});

function pickNearestNode(x,y,max){ let best=-1,bestD=max; for(let i=0;i<nodes.length;i++){const dx=x-nodes[i].x,dy=y-nodes[i].y,d=Math.hypot(dx,dy); if(d<bestD){bestD=d;best=i;}} return best; }

// Integration (Verlet)
function integrate(h,g,damping){
  const gStep=g*h*h;
  for(const p of nodes){
    let vx=(p.x-p.oldx)*(1-damping);
    let vy=(p.y-p.oldy)*(1-damping);
    const nx=p.x+vx, ny=p.y+vy+gStep;
    p.oldx=p.x; p.oldy=p.y; p.x=nx; p.y=ny;
  }
}

// Distance constraints + area + perimeter separation
function satisfyConstraints(globalStiff, areaStrength, sepMin, sepStrength){
  for(let k=0;k<ITERATIONS;k++){
    // springs
    for(const c of edges){
      const a=nodes[c.i], b=nodes[c.j];
      const dx=b.x-a.x, dy=b.y-a.y;
      const dist=Math.hypot(dx,dy)||1e-6;
      const diff=(dist-c.rest)/dist;
      const s=(c.k*globalStiff)*0.5;
      const ox=dx*diff*s, oy=dy*diff*s;
      a.x+=ox; a.y+=oy; b.x-=ox; b.y-=oy;
    }

    // area preservation (soft; scaled by gooiness)
    if (areaStrength>0){
      const pts = perimeter.map(i=>nodes[i]);
      const curArea = polygonArea(pts);
      const err = (curArea - originalArea) / Math.max(1, Math.abs(originalArea));
      const alpha = -err * areaStrength;
      // push perimeter nodes along approx outward normals
      for (let i=0;i<perimeter.length;i++){
        const i0 = perimeter[(i-1+perimeter.length)%perimeter.length];
        const i1 = perimeter[i];
        const i2 = perimeter[(i+1)%perimeter.length];
        const p0 = nodes[i0], p1 = nodes[i1], p2 = nodes[i2];
        const ex = p2.x - p0.x, ey = p2.y - p0.y;
        const nlen = Math.hypot(ex,ey)||1e-6;
        const nx = -ey/nlen, ny = ex/nlen;
        p1.x += nx * alpha * 0.6;
        p1.y += ny * alpha * 0.6;
      }
    }

    // perimeter self-separation to avoid triangle/edge intersection
    if (sepStrength>0){
      for (let a=0; a<perimeter.length; a++){
        for (let b=a+2; b<perimeter.length; b++){
          // skip neighbors and wrap-around neighbor
          if ((a===0 && b===perimeter.length-1)) continue;
          const ia = perimeter[a], ib = perimeter[b];
          const pa = nodes[ia], pb = nodes[ib];
          const dx = pb.x - pa.x, dy = pb.y - pa.y;
          const d = Math.hypot(dx,dy) || 1e-6;
          if (d < sepMin){
            const diff = (sepMin - d) / d * 0.5 * sepStrength;
            const ox = dx * diff, oy = dy * diff;
            pa.x -= ox; pa.y -= oy;
            pb.x += ox; pb.y += oy;
          }
        }
      }
    }
  }
}

function boxCollisions(bounce){
  const fric = 0.05; // tangential energy bleed on impact
  for(const p of nodes){
    let vx=p.x-p.oldx, vy=p.y-p.oldy;
    if(p.x<bounds.l){p.x=bounds.l; vx = -vx * bounce; vy *= (1 - fric);} 
    else if(p.x>bounds.r){p.x=bounds.r; vx = -vx * bounce; vy *= (1 - fric);} 
    if(p.y<bounds.t){p.y=bounds.t; vy = -vy * bounce; vx *= (1 - fric);} 
    else if(p.y>bounds.b){p.y=bounds.b; vy = -vy * bounce; vx *= (1 - fric);} 
    p.oldx=p.x-vx; p.oldy=p.y-vy;
  }
}

function render(){
  ctx.clearRect(0,0,W,H);
  // bounds
  ctx.strokeStyle="#394150"; ctx.lineWidth=2;
  ctx.strokeRect(bounds.l,bounds.t,bounds.r-bounds.l,bounds.b-bounds.t);
  // edges
  ctx.strokeStyle="white"; ctx.lineWidth=1;
  for(const e of edges){
    const a=nodes[e.i],b=nodes[e.j];
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  // nodes
  ctx.fillStyle="white";
  for(const p of nodes){ ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
}

function lerp(a,b,t){ return a + (b-a)*t; }

function update(){
  GRAVITY=parseFloat(gravitySlider.value); gravityVal.textContent=GRAVITY.toFixed(0);
  const goo=parseInt(gooSlider.value,10); gooVal.textContent=goo;
  const t = (goo-1)/9; // 0..1
  // Nonlinear maps for feel:
  //  - goo=1: very soft, high damping, almost no bounce, no area preservation
  //  - goo=10: stiff, low damping, very bouncy, decent area preservation
  const stiffness = lerp(0.03, 0.95, Math.pow(t, 0.7));
  const damping   = lerp(0.36, 0.04, t);
  const bounce    = lerp(0.02, 0.92, Math.pow(t, 1.25));
  const areaStr   = lerp(0.00, 0.30, Math.pow(t, 1.1)); // let it puddle at low goo
  const sepMin    = spacing * lerp(0.6, 0.9, t); // avoid perimeter intersection
  const sepStr    = lerp(0.6, 0.95, t);

  for(let s=0;s<SUBSTEPS;s++){
    integrate(1/60/SUBSTEPS,GRAVITY,damping);
    satisfyConstraints(stiffness, areaStr, sepMin, sepStr);
    boxCollisions(bounce);
  }
  if(dragIdx>=0){nodes[dragIdx].x=lastMouse.x; nodes[dragIdx].y=lastMouse.y;}
  render();
  requestAnimationFrame(update);
}

buildBlob();
update();
</script>
</body>
</html>
